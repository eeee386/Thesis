-- while writes out a plus false

var a = clock(); for (var i = 0; i < 1000000; i = i+1) {i;} var b = clock(); print b-a;

fun a(){return 5;} print a();

fun count(n) {while (n < 5) {if (n == 3) {print n;} n = n + 1;}} print count(1);

fun count(n) {while (n < 5) {print n; n = n + 1;}} print count(1);

fun count(n) {for (var i = 0; i < 5; i = i+1){ print i;}} count(1);

var a = 0; while(a < 5) {if(a == 3) {print a; break;} a=a+1; }

var a = 0; while(a < 5) {if(a == 3) {print a+6; break;} print a; a=a+1; }

var a = 0; while(a < 5) {if(a == 3) {a = a+1; continue;} a=a+1; print a; } print a;


for (var i = 0; i < 5; i = i+1){ print i;}

var a = 5; for (var i = 0; i < 5; i = i+1){ print i;}

var a = 5; if (a == 5){ print a*2; }
var a = 4; if (a <= 5){print a*2;}


for (var i = 0; i < 5; i = i+1){print i;}

// Fix "if without block, it does not see return after first return"
fun fib(n) {if (n <= 1) {return n;} return fib(n-2) + fib(n-1);} for (var i = 0; i < 20; i = i + 1) {print fib(i);}

fun addOne(n){print n; if (n == 5) {return n;} return addOne(n+1);} addOne(1);

fun ret(n){if(!n) {return n-1;} return n-3;} print ret(5);
fun ret(n){if(n) {return n-1;} return n-3;} print ret(5);

var n = 1 ;fun addOne(n){print n; if (n == 5) {return n;} return addOne(n+1);} addOne(n); print n;

fun a(n) {return n;} var b = a(5); print b;


fun addOne(n){print n; if (n > 7) {return n;} return addOne(n+1) + addOne(n+3);} addOne(1);


fun a(n) {return n;} fun b(n) {return a(n-1)+a(n-2);} print b(5) + b(4);

fun a(n) {return n;} fun b(n) {return a(n-1)+a(n-2);} print b(5);

fun a(n) {return n-1;} print a(5);

fun a(n) {return n;} print a(5);

fun add(a,b) {return a+b;} print add(1+3,2);

var n = 0; add(1,3)(1, 2);


fun makeCounter() {var i = 0; fun count() {i = i + 1;print i;}return count;}var counter = makeCounter(); print counter(); print counter();
fun makeCounter() {var i = 0; fun count() {i = i + 1;print i;}return count;}var counter = makeCounter()(); print counter;

var a = "global";{fun showA() {print a;}showA();var a = "block";showA();}

var a = 5; {a = 4;} print a;

var a = 5; if(a){print a;}

var a=5; {var a = 3; a = a+1;} print a;


class Breakfast {cook() {print \"Eggs a-fryin'!\";} serve(who) {print \"Enjoy your breakfast + \" + who + \".\";}} var a = Breakfast(); print a;


// together
// Function declarations were originally ID based but realized this edge case, where I realized the z would redeclare w and overwrite y's w declaration
fun v(a) {
    fun w() {print a;}
    return w;
}

fun x(){
    var y = v(5);
    var z = v(4);
    y();
}
x();

// w should write out 5;


//
fun a(b, c){
    class Animal{
        hello() {
          print b;
        }
    }
    return new Animal;
}
var d = a(1,2)
d.hello()
//

//
var a;
a();
//

//
var a = 1;

class B(){
  fun changeA(){
    a = a + 1;
  }
}

var c = B();
c.changeA();
print a;
//


//
fun a() {
  print "dummy"
}

a = 5;
//

//
class A{
  cook(){
    print "cook";
  }
}

class B < A {

}

var c = B();
c.cook();
//

//
fun a() {
  var i = 0;
  fun e(){
    var i = 2;
    print i;
  }
  return e;
}

var b = a();
b();
//

//
var a = 1;

class B {
  changeA(){
    a = a + 1;
  }
}
fun c() {
  B().changeA();
}
c();
print a;
//